#!/usr/bin/env bash
# vim:tw=0:ts=2:sw=2:et:norl:nospell:ft=sh
# Project: https://github.com/doblabs/easy-as-pypi#ðŸ¥§
# License: MIT

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

UPDEPS_LABEL_NAME_POETRY_LOCK="${UPDEPS_LABEL_NAME_POETRY_LOCK:-\
poetry.lock}"
UPDEPS_LABEL_DESC_POETRY_LOCK="${UPDEPS_LABEL_DESC_POETRY_LOCK:-\
Pull requests that update poetry.lock}"
UPDEPS_LABEL_NAME_INHIBIT_VERSION="${UPDEPS_LABEL_NAME_INHIBIT_VERSION:-\
ci-inhibit-version}"
UPDEPS_LABEL_DESC_INHIBIT_VERSION="${UPDEPS_LABEL_DESC_INHIBIT_VERSION:-\
Tells CI not to version after auto-merge}"
UPDEPS_LABEL_NAME_INHIBIT_CASCADE="${UPDEPS_LABEL_NAME_INHIBIT_CASCADE:-\
ci-inhibit-cascade}"
UPDEPS_LABEL_DESC_INHIBIT_CASCADE="${UPDEPS_LABEL_DESC_INHIBIT_CASCADE:-\
Tells CI not to cascade after release}"
UPDEPS_LABEL_NAME_PRERELEASE="${UPDEPS_LABEL_NAME_PRERELEASE:-\
ci-prerelease}"
UPDEPS_LABEL_DESC_PRERELEASE="${UPDEPS_LABEL_DESC_PRERELEASE:-\
Tells CI to use prerelease versions}"
UPDEPS_LABELS_COLOR="${UPDEPS_LABELS_COLOR:-74e34f}"

# CXREF: These are GH organization variables that GHA injects into env:
#   https://github.com/organizations/doblabs/settings/variables/actions
# - If you're running locally, git-config values will be used instead.
UPDEPS_USER_EMAIL="${UPDEPS_USER_EMAIL}"
UPDEPS_USER_NAME="${UPDEPS_USER_NAME_UPDEPS:-${UPDEPS_USER_NAME:-update-poetry}}"

# Optional: Customizable Git and GitHub message.
UPDEPS_COMMIT_MESSAGE="${UPDEPS_COMMIT_MESSAGE:-\
Build: Deps: Update poetry.lock [update-deps cascade]}"
UPDEPS_PR_TITLE="${UPDEPS_PR_TITLE:-Build: Bump poetry.lock (bump all)}"
UPDEPS_PR_BODY="${UPDEPS_PR_BODY:-Cascading release}"

# The UPDEPS_REPO_ORG_PROJ environ will be inferred at runtime.
# - You can also set from workflow, e.g.,
#     UPDEPS_REPO_ORG_PROJ="${{ github.repository }}" ./.github/bin/update-poetry
UPDEPS_REPO_ORG_PROJ="${UPDEPS_REPO_ORG_PROJ}"

# DEVXX: How you might test locally (but note PR self-approve fails):
__UPDEPS__CPYST__="
  UPDEPS_FAKE_UPDATE=true \
  UPDEPS_LABEL_INHIBIT_VERSION=true \
  UPDEPS_LABEL_INHIBIT_CASCADE=true \
  UPDEPS_LABEL_PRERELEASE=true \
    ./.github/bin/update-poetry
"

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

source_deps () {
  _updeps_insist_cmd 'git'
  _updeps_insist_cmd 'poetry'
  _updeps_insist_cmd 'gh'

  # Ensure coreutils installed (from Linux pkg. mgr., or from macOS Homebrew).
  _updeps_insist_cmd 'realpath'

  # For `print_scoped_head` (which uses `identify_scope_ends_at` from git-put-wise).
  # - Supports running this script on local Dev repo with PRIVATE commits.
  # CXREF: ~/.kit/git/git-update-faithful/lib/update-faithful.sh
  #   https://github.com/thegittinsgood/git-update-faithful#â›²
  # $0  on GHA: ./.github/bin/update-poetry
  # pwd on GHA: /home/runner/work/easy-as-pypi/easy-as-pypi
  . "$(dirname "$(realpath "$0")")/../deps/git-update-faithful/lib/update-faithful.sh"

  # INERT/2023-11-03: See git-nubs if you start adding too much Git.
  # # CXREF: https://github.com/landonb/sh-git-nubs#ðŸŒ°
  # #   ~/.kit/sh/sh-git-nubs/bin/git-nubs.sh
  # . "$(dirname "$(realpath "$0")")/../../deps/sh-git-nubs/bin/git-nubs.sh"
}

_updeps_insist_cmd () {
  local cmdname="$1"

  command -v "${cmdname}" > /dev/null && return 0 || true

  >&2 echo "ERROR: Missing system command â€˜${cmdname}â€™."

  exit 1
}

# Program prints "true" or "false" to stdout for CI workflow.
# Program prints to stderr for trace/progress messages.
print_prog () {
  >&2 printf "$1"
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

update_poetry_update () {
  assert_git_status_tidy

  assert_git_email_known

  local branch_name
  branch_name="$(print_branch_name)"

  local remote_name
  remote_name="$(git_upstream_remote)"

  poetry_update_lock

  assert_git_status_0_or_1_changes

  assert_git_status_only_poetry_lock_changed_if_any

  if test -n "$(git status --porcelain=v1)"; then
    prepare_branch "${branch_name}" "${remote_name}"

    poetry_update_commit_changes "${branch_name}"

    push_branch "${branch_name}" "${remote_name}"

    local NEW_PR_URL
    gh_pr_create_and_auto_merge_when_checks_finish

    resume_old_branch_and_cleanup "${branch_name}"

    # E.g., https://github.com/doblabs/easy-as-pypi/pull/51
    echo "$(basename "${NEW_PR_URL}")"
  fi
  # else, print nothing, means po-update was a no-op.
}

# ***

poetry_update_lock () {
  print_prog "poetry update... "

  if ! ${UPDEPS_FAKE_UPDATE:-false}; then
    # Meh: We could restrict to updating just our org's repos,
    # e.g., `poetry update doblabs/<pkg> doblabs/<pkg> ...`,
    # but no reason not to update everything.
    poetry update -q --lock
  else
    # DEVs: UPDEPS_FAKE_UPDATE is a faker to make (GHA) CI testing quicker.
    echo "# This line generated by poetry-update-faker" >> poetry.lock
  fi

  print_prog "âœ“\n"
}

# ***

TTTtt0 () {
  echo "$(date '+%Y%m%d%H%M')"
}

shorten_string () {
  local string="$1"
  local maxlen="${2:-12}"

  printf "${string}" | sed -E 's/^(.{'${maxlen}'}).*/\1/g'
}

git_HEAD_commit_sha () {
  git rev-parse HEAD
}

print_branch_name () {
  branch_name="update-deps/$(TTTtt0)/$(shorten_string "$(git_HEAD_commit_sha)")"

  printf "%s" "${branch_name}"
}

prepare_branch () {
  local branch_name="$1"
  local remote_name="$2"

  local scoped_head="HEAD"
  scoped_head="$(print_scoped_head ".")"

  print_prog "git checkout -b ${branch_name} ${scoped_head}\n"

  git checkout -q -b "${branch_name}" "${scoped_head}"
}

resume_old_branch_and_cleanup () {
  local branch_name="$1"

  git checkout -q -

  # Delete local branch when this script is run from user terminal (not from GHA).
  # - SAVVY: Use 'CI' environ to detect CI environment â€” this is the first
  #   environ that GH documents. Other candidates include 'GITHUB_ACTIONS'
  #   and 'GITHUB_ACTION'.
  #   - REFER:
  # https://docs.github.com/en/actions/learn-github-actions/variables#default-environment-variables
  if ! ${CI:-false}; then
    # FIXME: Might need Big D.
    # Ignore stderr message that -q doesn't inhibit:
    #   warning: deleting branch 'foo' that has been merged to
    #            'refs/remotes/origin/foo', but not yet merged to HEAD.
    git branch -q -d "${branch_name}" 2> /dev/null
  fi
}

poetry_update_commit_changes () {
  print_prog "git add poetry.lock\n"

  git add poetry.lock

  print_prog "git commit... "

  # See comment above: GHA defines CI=true.
  if ${CI:-false}; then
    git config user.email "${UPDEPS_USER_EMAIL}"
    git config user.name "${UPDEPS_USER_NAME}"
  fi

  git commit -q -m "${UPDEPS_COMMIT_MESSAGE}"

  print_prog "âœ“\n"
}

# ***

# SAVVY: We'll look for the remote name that uses a GitHub URL and
# assume that's the github.com/<org>/<proj> repo.
# - For a GitHub Actions workflow, this'll be the default 'origin'
#   remote.
# - But when run from a local dev terminal, don't assume what remote
#   they're using (e.g., the author has a *system* and doesn't use
#   'origin', but uses different remote names for different purposes).

push_branch () {
  local branch_name="$1"
  local remote_name="$2"

  print_prog "git push '${remote_name}'... "

  # Even though --quiet, any message from the remote is printed to stderr, e.g.,:
  #   remote:
  #   remote: Create a pull request for 'foo' on GitHub by visiting:
  #   remote:      https://github.com/doblabs/easy-as-pypi/pull/new/foo
  #   remote:

  # Note the -u/--set-upstream, which avoids gh-pr-create asking which remote.

  # Note the workflow caller called checkout using the classic user token
  # (with 'public_repo' access), and not the default github-actions token.
  # By using a personal access token, the git-push triggers our 'checks'
  # workflow to run. (The normal GH_TOKEN=${{ github.token }} inhibits
  # workflow events.)

  git push -q -u ${remote_name} "HEAD:refs/heads/${branch_name}" 2> /dev/null

  print_prog "âœ“\n"
}

# Look for the GH.com/org/proj remote name.
# - We assume it's the one using the git@ SSH creds,
#   or has github.com/ in its path.
# - We don't default to the sole remote if that's all there is.
#   We're looking for a specific github.com/<org>/<proj> remote.
git_upstream_remote () {
  if [ -z "${UPDEPS_REPO_ORG_PROJ}" ]; then
    local repo_url

    repo_url="$(print_upstream_remote_url)" || exit 1

    if [ -n "${repo_url}" ]; then
      # Trim, e.g., https://github.com/doblabs/easy-as-pypi â†’ doblabs/easy-as-pypi
      # - Result is same as ${{ github.repository }}
      UPDEPS_REPO_ORG_PROJ="$(
        echo "${repo_url}" | sed 's#^.*/\([^/]*/[^/]*\)$#\1#'
      )"

      if [ -z "${UPDEPS_REPO_ORG_PROJ}" ]; then
        >&2 echo "ERROR: Could not deduce project repo from URL: ${repo_url}"

        exit 1
      fi
    else
      >&2 echo "ERROR: Could not deduce remote URL from remotes or pyproject.toml"
      >&2 echo "- Check pyproject.toml values for 'repository' or 'homepage'"
      >&2 echo "  from [tool.poetry] or [tool.poetry.urls]"
      >&2 echo "- Check \`git remote get-url origin\`"

      exit 1
    fi
  fi

  if ! git_upstream_remote_deduce; then
    # Note that we're ignoring the tracking branch. We want our GH
    # org/proj repo. Which we didn't find.
    >&2 echo "ERROR: Could not determine the upstream GitHub remote"
    >&2 echo "- We checked UPDEPS_REPO_ORG_PROJ (â€œ${UPDEPS_REPO_ORG_PROJ}â€)"
    >&2 echo "  against these remotes:"
    >&2 echo git remote -v

    exit 1
  fi
}

print_upstream_remote_url () {
  if ${CI:-false}; then
    git remote get-url "origin"
  else
    print_upstream_remote_url_from_pyproject_toml
  fi
}

print_upstream_remote_url_from_pyproject_toml () {
  if ! _updeps_insist_cmd 'tomlq'; then
    >&2 echo "ERROR: Could not deduce upstream remote"
    >&2 echo "- Please run from venv with \`tomlq\` installed"
    >&2 echo "- Or set the 'UPDEPS_REPO_ORG_PROJ' environ"

    exit 1
  fi

  # REFER: https://github.com/jqlang/jq/issues/354
  local trim_null="select( . != null )"

  if true \
    && ! tomlq -r -e ".tool.poetry.repository      | ${trim_null}" "pyproject.toml" \
    && ! tomlq -r -e ".tool.poetry.urls.repository | ${trim_null}" "pyproject.toml" \
    && ! tomlq -r -e ".tool.poetry.homepage        | ${trim_null}" "pyproject.toml" \
    && ! tomlq -r -e ".tool.poetry.urls.homepage   | ${trim_null}" "pyproject.toml" \
  ; then
    >&2 echo "ERROR: Could not deduce remote URL from pyproject.toml"
    >&2 echo "- pyproject.toml is missing 'repository' or 'homepage'"
    >&2 echo "  from [tool.poetry] or [tool.poetry.urls]"
    >&2 echo "- You can also set 'UPDEPS_REPO_ORG_PROJ' environ directly"

    exit 1
  fi
}

git_upstream_remote_deduce () {
  git remote -v \
    | grep \
        -e "[[:space:]]git@.*:${UPDEPS_REPO_ORG_PROJ}\(\.git\)\? (push)\$" \
        -e "github.com/${UPDEPS_REPO_ORG_PROJ}\(\.git\)\? (push)\$" \
    | sed 's/^\([^[:space:]]\+\).*/\1/'
}

# ***

# We use 2 different GH tokens for git and `gh` commands:
# - We used User PAT for git-checkout so that git-commit triggers
#   workflow events (and our 'checks' in particular, so PR checks
#   pass, auto-merge trigger). When authenticated by the default
#   github.token, git-push inhibits workflow events.
# - In the function below, the User PAT is used to create the PR,
#   but the GH token is used to approve it. This gets around the
#   Branch protection approval-required rule, if it's set.
#   - Note if the tokens were reversed -- if the GH token creates PR
#     and the User PAT approves the PR, then the PR-closed workflow
#     will not run (for the reason stated above, because the GH token
#     inhibits workflow events).
#   - Furthermore, because GH token created the PR, GH token owns the
#     auto-merge, and Git history shows it. E.g., GH commit history
#     shows "user authored and github-actions[bot] committed", vs.
#     what you'd probably like to see, e.g., "user committed". Indeed,
#     in the Git history, the Committer is the git-commit user from
#     this script, and the Author is whoever owns the auto-merge PR..

# REFER/CXREF:
#   If you do want to trigger a workflow from within a workflow run, you can
#   use a GitHub App installation access token or a personal access token
#   instead of GITHUB_TOKEN to trigger events that require a token.
# https://docs.github.com/en/actions/using-workflows/triggering-a-workflow#triggering-a-workflow-from-a-workflow
# https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens

gh_pr_create_and_auto_merge_when_checks_finish () {
  gh_label_create_poetry_lock_label

  local pr_ci_labels=""
  pr_ci_labels="$(print_pr_ci_labels)"

  NEW_PR_URL="$(gh_pr_create "${pr_ci_labels}")"

  gh_pr_set_auto_merge_delete_rebase "${NEW_PR_URL}"

  gh_pr_approve "${NEW_PR_URL}"

  print_prog "New PR\n  ${NEW_PR_URL}\n"
}

gh_label_create_poetry_lock_label () {
  gh_label_create \
    "${UPDEPS_LABEL_NAME_POETRY_LOCK}" \
    "${UPDEPS_LABEL_DESC_POETRY_LOCK}"
}

# Here's the label that dependabot uses, for reference:
#
#   gh label create \
#     "dependencies" \
#     --description "Pull requests that update a dependency file" \
#     --color 0366d6

gh_label_create () {
  local label_name="$1"
  local label_desc="$2"

  print_prog "gh label create \"${label_name}\"...\n"

  GH_TOKEN=${USER_TOKEN} \
  gh label create -f \
    "${label_name}" \
    --description "${label_desc}" \
    --color "${UPDEPS_LABELS_COLOR}"
}

# Meh: This feels like TMBL â€” Too Much Business Logic â€” than maybe belongs here.
print_pr_ci_labels () {
  if ${UPDEPS_LABEL_INHIBIT_VERSION:-false}; then
    gh_label_create \
      "${UPDEPS_LABEL_NAME_INHIBIT_VERSION}" \
      "${UPDEPS_LABEL_DESC_INHIBIT_VERSION}"

    printf "%s" "--label ${UPDEPS_LABEL_NAME_INHIBIT_VERSION} "
  fi

  if ${UPDEPS_LABEL_INHIBIT_CASCADE:-false}; then
    gh_label_create \
      "${UPDEPS_LABEL_NAME_INHIBIT_CASCADE}" \
      "${UPDEPS_LABEL_DESC_INHIBIT_CASCADE}"

    printf "%s" "--label ${UPDEPS_LABEL_NAME_INHIBIT_CASCADE} "
  fi

  if ${UPDEPS_LABEL_PRERELEASE:-false}; then
    gh_label_create \
      "${UPDEPS_LABEL_NAME_PRERELEASE}" \
      "${UPDEPS_LABEL_DESC_PRERELEASE}"

    printf "%s" "--label ${UPDEPS_LABEL_NAME_PRERELEASE} "
  fi
}

gh_pr_create () {
  local pr_ci_labels="$1"

  local pr_title="${UPDEPS_PR_TITLE}"
  local pr_body="${UPDEPS_PR_BODY}"
  local new_pr_url

  print_prog "gh pr create --title \"${pr_title}\" --body \"${pr_body}\"" \
    "--label "${UPDEPS_LABEL_NAME_POETRY_LOCK}" ${pr_ci_labels}\n"

  # Create PR from user PAT so on auto-merge, it triggers workflow events.

  new_pr_url="$(
    GH_TOKEN=${USER_TOKEN} \
    gh pr create \
      --title "${pr_title}" \
      --body "${pr_body}" \
      --label "${UPDEPS_LABEL_NAME_POETRY_LOCK}" \
      ${pr_ci_labels} \
    | tail -1
  )"

  printf "%s" "${new_pr_url}"
}

gh_pr_set_auto_merge_delete_rebase () {
  local pr_ref="$1"

  # Note that --delete-branch has no effect, or at least it was ineffective
  # until I enabled "Automatically delete head branches" (Settings > General),
  # which makes it sound like it's still probably effectiveless.

  print_prog "gh pr merge \"${pr_ref}\" --auto --delete-branch --rebase\n"

  GH_TOKEN=${USER_TOKEN} \
  gh pr merge "${pr_ref}" --auto --delete-branch --rebase
}

# CXREF: https://github.com/doblabs/easy-as-pypi/settings/actions
#   âœ“ Allow GitHub Actions to create and approve pull requests
# - Albeit trying to run from a user terminal:
#     failed to create review: GraphQL:
#       Can not approve your own pull request (addPullRequestReview)
#   Because Branch protection rules require one reviewer, who cannot
#   be creater.
#   - So always be truthy (|| true), becayse this may fail when run
#     locally, i.e., from user terminal and not from GH Actions, if
#     Branch protection rules require at least 1 reviewer (because
#     users cannot approve their own PRs, and when run locally,
#     pr-create and pr-review run as same user most likely).
gh_pr_approve () {
  local pr_ref="$1"

  print_prog "gh pr review --approve \"${pr_ref}\" --comment \"LGTM!\"\n"

  # Approve PR using github-actions bot, to bypass anti-self-approve
  # branch protection rule.

  GH_TOKEN=${GBOT_TOKEN} \
  gh pr review "${pr_ref}" --approve --body "LGTM!" \
    || true
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

assert_git_email_known () {
  if ${CI:-false}; then
    assert_git_email_known_ci
  else
    assert_git_email_known_interactive
  fi
}

assert_git_email_known_ci () {
  test -n "${UPDEPS_USER_EMAIL}" \
    && return 0 || true

  >&2 echo "ERROR: Please set UPDEPS_USER_EMAIL organization or project variable"

  exit 1
}

assert_git_email_known_interactive () {
  test -n "$(git config user.email)" \
    && return 0 || true

  >&2 echo "ERROR: Who are you? \`git config user.email\` says you're nobody"

  exit 1
}

assert_git_status_tidy () {
  test -z "$(git status --porcelain=v1)" \
    && return 0 || true

  >&2 echo "ERROR: $(basename "$0") requires a tidy repo"

  exit 1
}

# Overly cautious git-status check (expect 0 or 1 changes).
assert_git_status_0_or_1_changes () {
  test $(git status --porcelain=v1 | wc -l) -le 1 \
    && return 0 || true

  >&2 echo "ERROR: Unexpected: More than 1 file changed by poetry-update?!"

  exit 1
}

# Overly cautious git-status check (expect only poetry.lock).
assert_git_status_only_poetry_lock_changed_if_any () {
  test -z "$(git status --porcelain=v1)" \
    && return 0 || true

  test "$(git status --porcelain=v1)" = " M poetry.lock" \
    && return 0 || true

  >&2 echo "ERROR: Unexpected: poetry.lock is not sole change after poetry-update?!"

  exit 1
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

main () {
  set -e

  source_deps

  update_poetry_update "$@"
}

if [ "$0" = "${BASH_SOURCE[0]}" ]; then
  # Being executed, so execute.
  main "$@"
fi

unset -f main
unset -f source_deps

