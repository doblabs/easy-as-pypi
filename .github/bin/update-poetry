#!/usr/bin/env bash
# vim:tw=0:ts=2:sw=2:et:norl:nospell:ft=sh
# Project: https://github.com/doblabs/easy-as-pypi#ðŸ¥§
# License: MIT

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

source_deps () {
  insist_cmd 'git'
  insist_cmd 'poetry'
  insist_cmd 'gh'
# MAYBE/2023-11-03 15:59: Use git-nubs?
  # # Ensure coreutils installed (from Linux pkg. mgr., or from macOS Homebrew).
  # insist_cmd 'realpath'
  #
  # # CXREF: https://github.com/landonb/sh-git-nubs#ðŸŒ°
  # #   ~/.kit/sh/sh-git-nubs/bin/git-nubs.sh
  # . "$(dirname "$(realpath "$0")")/../deps/sh-git-nubs/bin/git-nubs.sh"
}

insist_cmd () {
  local cmdname="$1"

  command -v "${cmdname}" > /dev/null && return 0

  >&2 echo "ERROR: Missing system command â€˜${cmdname}â€™."

  exit 1
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

update_poetry_update () {
  assert_git_status_tidy

  # Meh: We could restrict to updating just our org's repos,
  # e.g., `poetry update doblabs/<pkg> doblabs/<pkg> ...`,
  # but no reason not to update everything.
  poetry update --lock

  # local git_status_output="$(git status --porcelain=v1)"

  assert_git_status_0_or_1_changes

  assert_git_status_only_poetry_lock_changed_if_any

  if test -z "$(git status --porcelain=v1)"; then
    echo "false"
  else
    commit_changes

    echo "true"
  fi
}

# FIXME/2023-11-03: Make the strings below user-configurable,
# including: Branch name, Commit message, PR name/title.
commit_changes () {
  TTTtt0 () {
    echo "$(date '+%Y%m%d%H%M')"
  }

  shorten_string () {
    local string="$1"
    local maxlen="${2:-12}"

    printf "${string}" | sed -E 's/^(.{'${maxlen}'}).*/\1/g'
  }

  git_HEAD_commit_sha () {
    git rev-parse HEAD
  }

  branch_name="update-deps/$(TTTtt0)/$(shorten_string "$(git_HEAD_commit_sha)")"

  git checkout -b "${branch_name}"

  git add poetry.lock

  git commit -m "Build: Deps: Update poetry.lock [update-deps cascade]"

  local new_pr_url

  # --base is new branch's tracking branch, aka default branching
  # (assuming running from GH Action that checked out the default
  # branch).
  new_pr_url="$( \
    gh pr create \
      --title "Build: Bump poetry.lock (bump all)" \
      --body "Cascading release"
  )"

  gh pr merge "${new_pr_url}" --auto --delete-branch --rebase
}

# ***

assert_git_status_tidy () {
  test -z "$(git status --porcelain=v1)" \
    && return 0

  >&2 echo "ERROR: $(basename "$0") requires a tidy repo"

  exit 1
}

# Overly cautious git-status check (expect 0 or 1 changes).
assert_git_status_0_or_1_changes () {
  test $(git status --porcelain=v1 | wc -l) -le 1 \
    && return 0

  >&2 echo "ERROR: Unexpected: More than 1 file changed by poetry-update?!"

  exit 1
}

# Overly cautious git-status check (expect only poetry.lock).
assert_git_status_only_poetry_lock_changed_if_any () {
  test -z "$(git status --porcelain=v1)" \
    && return 0

  test "$(git status --porcelain=v1)" = " M poetry.lock" \
    && return 0

  >&2 echo "ERROR: Unexpected: poetry.lock is not sole change after poetry-update?!"

  exit 1
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

main () {
  set -e

  source_deps

  update_poetry_update "$@"
}

# Run the command iff being executed.
if ! $(printf %s "$0" | grep -q -E '(^-?|\/)(ba|da|fi|z)?sh$' -); then
  main "$@"
fi

unset -f main
unset -f source_deps
unset -f insist_cmd

