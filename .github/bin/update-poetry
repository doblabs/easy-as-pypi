#!/usr/bin/env bash
# vim:tw=0:ts=2:sw=2:et:norl:nospell:ft=sh
# Project: https://github.com/doblabs/easy-as-pypi#ðŸ¥§
# License: MIT

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# FIXME/2023-11-04 04:43: Customize this for each project.
# - Should workflow pass it in?
# - What about running locally?
# USAGE: From GHA, e.g.,
#   REPO_ORG_PROJ="${{ github.repository }}" ./.github/bin/update-poetry
REPO_ORG_PROJ="${REPO_ORG_PROJ:-doblabs/easy-as-pypi}"

# FIXME/2023-11-03: Make the strings in functions below user-configurable,
# including: Branch name, Commit message, PR name/title.
UPDEPS_LABEL_NAME="poetry.lock"

# FIXME/2023-11-04: Let user set these, somehow.
UPDEPS_USER_EMAIL="landonb@users.noreply.github.com"
UPDEPS_USER_NAME="update-poetry"

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

source_deps () {
  insist_cmd 'git'
  insist_cmd 'poetry'
  insist_cmd 'gh'

  # Ensure coreutils installed (from Linux pkg. mgr., or from macOS Homebrew).
  insist_cmd 'realpath'

  # For `print_canon_scoped_head` (which uses `identify_scope_ends_at` from git-put-wise).
  # - Supports running this script on local Dev repo with PRIVATE commits.
  # CXREF: ~/.kit/git/ohmyrepos/lib/update-faithful.sh
  #   https://github.com/landonb/ohmyrepos#ðŸ˜¤
  # $0 on GHA: ./.github/bin/update-poetry
  # pwd on GHA: /home/runner/work/easy-as-pypi/easy-as-pypi
  . "$(dirname "$(realpath "$0")")/../../deps/git-update-faithful/lib/update-faithful.sh"

  # INERT/2023-11-03: See git-nubs if you start adding too much Git.
  # # CXREF: https://github.com/landonb/sh-git-nubs#ðŸŒ°
  # #   ~/.kit/sh/sh-git-nubs/bin/git-nubs.sh
  # . "$(dirname "$(realpath "$0")")/../../deps/sh-git-nubs/bin/git-nubs.sh"
}

insist_cmd () {
  local cmdname="$1"

  command -v "${cmdname}" > /dev/null && return 0 || true

  >&2 echo "ERROR: Missing system command â€˜${cmdname}â€™."

  exit 1
}

# Program prints "true" or "false" to stdout for CI workflow.
# Program prints to stderr for trace/progress messages.
print_prog () {
  >&2 printf "$1"
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

update_poetry_update () {
  assert_git_status_tidy

  print_prog "poetry update... "

  # Meh: We could restrict to updating just our org's repos,
  # e.g., `poetry update doblabs/<pkg> doblabs/<pkg> ...`,
  # but no reason not to update everything.
  poetry update -q --lock

  print_prog "âœ“\n"

  assert_git_status_0_or_1_changes

  assert_git_status_only_poetry_lock_changed_if_any

  if test -z "$(git status --porcelain=v1)"; then
    echo "false"
  else
    local branch_name
    branch_name="$(print_branch_name)"

    local remote_name
    remote_name="$(git_upstream_remote)"

    prepare_branch "${branch_name}" "${remote_name}"

    poetry_update_commit_changes "${branch_name}"

    push_branch "${branch_name}"

    gh_pr_create_and_auto_merge_when_checks_finish

    resume_old_branch_and_cleanup "${branch_name}"

    echo "true"
  fi
}

# ***

TTTtt0 () {
  echo "$(date '+%Y%m%d%H%M')"
}

shorten_string () {
  local string="$1"
  local maxlen="${2:-12}"

  printf "${string}" | sed -E 's/^(.{'${maxlen}'}).*/\1/g'
}

git_HEAD_commit_sha () {
  git rev-parse HEAD
}

print_branch_name () {
  branch_name="update-deps/$(TTTtt0)/$(shorten_string "$(git_HEAD_commit_sha)")"

  printf "%s" "${branch_name}"
}

prepare_branch () {
  local branch_name="$1"
  local remote_name="$2"

  local scoped_head="HEAD"
  scoped_head="$(print_canon_scoped_head ".")"

  print_prog "git checkout -b ${branch_name} ${scoped_head}\n"

  git checkout -q -b "${branch_name}" "${scoped_head}"
}

resume_old_branch_and_cleanup () {
  local branch_name="$1"

  git checkout -q -

  # Delete local branch when this script is run from user terminal (not from GHA).
  if test -z "${GITHUB_ACTIONS}"; then
    # FIXME: Might need Big D.
    # Ignore stderr message that -q doesn't inhibit:
    #   warning: deleting branch 'foo' that has been merged to
    #            'refs/remotes/origin/foo', but not yet merged to HEAD.
    git branch -q -d "${branch_name}" 2> /dev/null
  fi
}

poetry_update_commit_changes () {
  print_prog "git add poetry.lock\n"

  git add poetry.lock

  print_prog "git commit... "

  # REFER/2023-11-04: I found GITHUB_ACTIONS when inspecting GHA runtime
  #                   with `env`, not sure if it's documented.

  if ${GITHUB_ACTIONS:-false} \
    && test -z "$(git config user.email)" \
    && test -z "$(git config user.name)" \
  ; then
    # We could use git's -c option, e.g.,
    #   local commit_user=""
    #   commit_user="-c user.email=\"${email}\" -c user.name=\"${name}\""
    # but then we'd need to use eval because of the embedded quotes, e.g.,
    #   # Using eval, because of the possibly empty string commit_user.
    #   eval "git ${commit_user} commit -q -m "..."
    # So we'll go the cleaner route.
    git config user.email "${UPDEPS_USER_EMAIL}"
    git config user.name "${UPDEPS_USER_NAME}"
  fi

  git commit -q -m "Build: Deps: Update poetry.lock [update-deps cascade]"

  print_prog "âœ“\n"
}

# ***

# SAVVY: We'll look for the remote name that uses a GitHub URL and
# assume that's the github.com/<org>/<proj> repo.
# - For a GitHub Actions workflow, this'll be the default 'origin'
#   remote.
# - But when run from a local dev terminal, don't assume what remote
#   they're using (e.g., the author has a *system* and doesn't use
#   'origin', but uses different remote names for different purposes).

push_branch () {
  local branch_name="$1"

  local remote_name
  remote_name="$(git_upstream_remote)"

  print_prog "git push '${remote_name}'... "

  # Even though --quiet, any message from the remote is printed to stderr, e.g.,:
  #   remote:
  #   remote: Create a pull request for 'foo' on GitHub by visiting:
  #   remote:      https://github.com/doblabs/easy-as-pypi/pull/new/foo
  #   remote:

  # Note the -u/--set-upstream, which avoids gh-pr-create asking which remote.

  # Note the workflow caller called checkout using the classic user token
  # (with 'public_repo' access), and not the default github-actions token.
  # By using a personal access token, the git-push triggers our 'checks'
  # workflow to run. (The normal GH_TOKEN=${{ github.token }} inhibits
  # workflow events.)

  git push -q -u ${remote_name} "HEAD:refs/heads/${branch_name}" 2> /dev/null

  print_prog "âœ“\n"
}

# Look for the GH.com/org/proj remote name.
# - We assume it's the one using the git@ SSH creds,
#   or has github.com/ in its path.
# - We don't default to the sole remote if that's all there is.
#   We're looking for a specific github.com/<org>/<proj> remote.
git_upstream_remote () {
# FIXME/2023-11-04: Remove this trace:
>&2 echo git remote -v
>&2 git remote -v
>&2 echo

  if [ -z "${REPO_ORG_PROJ}" ]; then
    >&2 echo "ERROR: Please set REPO_ORG_PROJ before calling update-poetry"

    exit 1
  fi

  if ! git_upstream_remote_deduce; then
    # Note that we're ignoring the tracking branch. We want our GH
    # org/proj repo. Which we didn't find.
    >&2 echo "ERROR: Could not determine the upstream GitHub remote"
    >&2 echo "- We checked REPO_ORG_PROJ (â€œ${REPO_ORG_PROJ}â€)"
    >&2 echo "  against these remotes:"
    >&2 echo git remote -v

    exit 1
  fi
}

git_upstream_remote_deduce () {
  git remote -v \
    | grep \
        -e "[[:space:]]git@.*:${REPO_ORG_PROJ}\(\.git\)\? (push)\$" \
        -e "github.com/${REPO_ORG_PROJ}\(\.git\)\? (push)\$" \
    | sed 's/^\([^[:space:]]\+\).*/\1/'
}

# ***

# We use 2 different GH tokens for git and `gh` commands:
# - We used User PAT for git-checkout so that git-commit triggers
#   workflow events (and our 'checks' in particular, so PR checks
#   pass, auto-merge trigger). When authenticated by the default
#   github.token, git-push inhibits workflow events.
# - In the function below, the User PAT is used to create the PR,
#   but the GH token is used to approve it. This gets around the
#   Branch protection approval-required rule, if it's set.
#   - Note if the tokens were reversed -- if the GH token creates PR
#     and the User PAT approves the PR, then the PR-closed workflow
#     will not run (for the reason stated above, because the GH token
#     inhibits workflow events).
#   - Furthermore, because GH token created the PR, GH token owns the
#     auto-merge, and Git history shows it. E.g., GH commit history
#     shows "user authored and github-actions[bot] committed", vs.
#     what you'd probably like to see, e.g., "user committed". Indeed,
#     in the Git history, the Committer is the git-commit user from
#     this script, and the Author is whoever owns the auto-merge PR..

# REFER/CXREF:
#   If you do want to trigger a workflow from within a workflow run, you can
#   use a GitHub App installation access token or a personal access token
#   instead of GITHUB_TOKEN to trigger events that require a token.
# https://docs.github.com/en/actions/using-workflows/triggering-a-workflow#triggering-a-workflow-from-a-workflow
# https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens

gh_pr_create_and_auto_merge_when_checks_finish () {
  gh_label_create

  local new_pr_url
  new_pr_url="$(gh_pr_create)"

  gh_pr_set_auto_merge_delete_rebase "${new_pr_url}"

  gh_pr_approve "${new_pr_url}"

  print_prog "New PR\n  ${new_pr_url}\n"
}

gh_label_create () {
  print_prog "gh label create ${UPDEPS_LABEL_NAME}...\n"

  # Here's the label that dependabot uses, for reference:
  #
  #   gh label create \
  #     "dependencies" \
  #     --description "Pull requests that update a dependency file" \
  #     --color 0366d6

  GH_TOKEN=${USER_TOKEN} \
  gh label create -f \
    "${UPDEPS_LABEL_NAME}" \
    --description "Pull requests that update poetry.lock" \
    --color 74e34f
}

gh_pr_create () {
  local pr_title="Build: Bump poetry.lock (bump all)"
  local pr_body="Cascading release"
  local new_pr_url

  print_prog "gh pr create --title \"${pr_title}\" --body \"${pr_body}\"\n"

  # Create PR from user PAT so on auto-merge, it triggers workflow events.

  new_pr_url="$(
    GH_TOKEN=${USER_TOKEN} \
    gh pr create \
      --title "${pr_title}" \
      --body "${pr_body}" \
      --label "${UPDEPS_LABEL_NAME}" \
    | tail -1
  )"

  printf "%s" "${new_pr_url}"
}

gh_pr_set_auto_merge_delete_rebase () {
  local new_pr_url="$1"

  # Note that --delete-branch has no effect, or at least it was ineffective
  # until I enabled "Automatically delete head branches" (Settings > General),
  # which makes it sound like it's still probably effectiveless.

  print_prog "gh pr merge \"${new_pr_url}\" --auto --delete-branch --rebase\n"

  GH_TOKEN=${USER_TOKEN} \
  gh pr merge "${new_pr_url}" --auto --delete-branch --rebase
}

# CXREF: https://github.com/doblabs/easy-as-pypi/settings/actions
#   âœ“ Allow GitHub Actions to create and approve pull requests
# - Albeit trying to run from a user terminal:
#     failed to create review: GraphQL:
#       Can not approve your own pull request (addPullRequestReview)
#   Because Branch protection rules require one reviewer, who cannot
#   be creater.
#   - So always be truthy (|| true), becayse this may fail when run
#     locally, i.e., from user terminal and not from GH Actions, if
#     Branch protection rules require at least 1 reviewer (because
#     users cannot approve their own PRs, and when run locally,
#     pr-create and pr-review run as same user most likely).
gh_pr_approve () {
  local new_pr_url="$1"

  print_prog "gh pr review --approve \"${new_pr_url}\" --comment \"LGTM!\"\n"

  # Approve PR using github-actions bot, to bypass anti-self-approve
  # branch protection rule.

  GH_TOKEN=${GBOT_TOKEN} \
  gh pr review "${new_pr_url}" --approve --body "LGTM!" \
    || true
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

assert_git_status_tidy () {
  test -z "$(git status --porcelain=v1)" \
    && return 0 || true

  >&2 echo "ERROR: $(basename "$0") requires a tidy repo"

  exit 1
}

# Overly cautious git-status check (expect 0 or 1 changes).
assert_git_status_0_or_1_changes () {
  test $(git status --porcelain=v1 | wc -l) -le 1 \
    && return 0 || true

  >&2 echo "ERROR: Unexpected: More than 1 file changed by poetry-update?!"

  exit 1
}

# Overly cautious git-status check (expect only poetry.lock).
assert_git_status_only_poetry_lock_changed_if_any () {
  test -z "$(git status --porcelain=v1)" \
    && return 0 || true

  test "$(git status --porcelain=v1)" = " M poetry.lock" \
    && return 0 || true

  >&2 echo "ERROR: Unexpected: poetry.lock is not sole change after poetry-update?!"

  exit 1
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

main () {
  set -e

  source_deps

  update_poetry_update "$@"
}

# Run the command iff being executed.
if ! $(printf %s "$0" | grep -q -E '(^-?|\/)(ba|da|fi|z)?sh$' -); then
  main "$@"
fi

unset -f main
unset -f source_deps
unset -f insist_cmd

