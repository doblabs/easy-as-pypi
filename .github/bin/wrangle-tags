#!/usr/bin/env bash
# vim:tw=0:ts=2:sw=2:et:norl:nospell:ft=sh
# Project: https://github.com/doblabs/easy-as-pypi#🥧
# License: MIT

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# USYNC: See ./.github/bin/update-poetry, which uses similarly-
#        named GitHub PR labels for the same Git tags named here.
#
#        - We use Git tags to message across the release process,
#          between the PyPI release workflow, and the smoke test.
#
#        - We use GitHub PR labels to message across the poetry-
#          update process.
#
#        In both instances, the workflow effectively ends before resuming
#        again after some event happens. And we cannot use GHA workflow
#        artifacts, which only persist throughout a single workflow, to
#        communicate between workflows.
#
#        So these mechanisms (PR labels, and Git tags), seem like the
#        (only) obvious choice to handle end-to-end workflow settings.
#
#        - And there's no reason the Git tags and the GH labels have
#          to be named the same, except they represent the same value
#          we want to carry through the cascade workflows.
#

EAPP_CI_TAG_INHIBIT_CASCADE="ci-inhibit-cascade"
EAPP_CI_TAG_INHIBIT_CASCADE_ALWAYS="ci-inhibit-cascade-always"

EAPP_CI_TAG_CASCADE_LEAST="ci-cascade-least"
EAPP_CI_TAG_CASCADE_ALPHA="ci-cascade-alpha"
EAPP_CI_TAG_CASCADE_PATCH="ci-cascade-patch"
EAPP_CI_TAG_CASCADE_SKIP_DEPS="ci-cascade-no-update-deps"
EAPP_CI_TAG_CASCADE_SKIP_VERS="ci-cascade-no-version-tag"

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

wrangle_tags () {
  declare -a tag_names
  # CRUDE: Set tag_names array.
  set_tag_locals ""

  trace_full

  trace_lite "┌─ CI tags wrangler: ─────────┬────────────────┬───────────────────────────────────┐"

  for which_tag in "${tag_names[@]}"; do
    trace_full "which tag: ${which_tag}"

    local tag_name
    local tag_setting
    local tag_scope
    local output_name
    local skip_if
    # CRUDE: Set `local` vars for specified tag.
    set_tag_locals "${which_tag}"

    wrangle_tag \
      "${tag_name}" \
      "${tag_setting}" \
      "${tag_scope}" \
      "${output_name}" \
      "${skip_if}"

    trace_full
  done

  trace_lite "└─────────────────────────────┴────────────────┴───────────────────────────────────┘"
}

# ***

wrangle_tag () {
  local tag_name="$1"
  local tag_setting="$2"
  local tag_scope="$3"
  local output_name="$4"
  local skip_if="$5"

  trace_full "manage-ci-tag @ $(git rev-parse HEAD)"
  trace_full "- tag_name: ${tag_name}"
  trace_full "- tag_setting: ${tag_setting}"
  trace_full "- tag_scope: ${tag_scope}"
  trace_full "- output_name: ${output_name}"
  trace_full "- skip_if?: ${skip_if}"

  if ${skip_if}; then
    return 0
  fi

  local was_enabled=false

  if [ "${tag_scope}" = "HEAD" ]; then
    # A "HEAD" tag is only valid if on HEAD commit.
    # - This branch followed by all tags but 'ci-inhibit-forever'.
    local head_tag_match="$(git tag --list --points-at HEAD "${tag_name}")"

    if [ -n "${head_tag_match}" ]; then
      was_enabled=true
    fi
  else
    # A "branch" tag is valid if it's on any commit in the branch.
    # - This code path followed by only the 'ci-inhibit-forever'
    #   tag (for now, says 2023-11-22).

    # Use not-fully-qualified branch name because refs/heads/<branch> doesn't
    # work with git-branch (so not `git rev-parse --symbolic-full-name HEAD`).
    local default_branch="$(git rev-parse --abbrev-ref=loose HEAD)"

    # - The name pattern — ${default_branch} — is ^strict$ w/out wildcards.
    # - If tag absent, dies: 'error: malformed object name refs/tags/foo'.
    local branch_tag_match
    if branch_tag_match="$(
      git branch --list --contains "refs/tags/${tag_name}" "${default_branch}" \
        2> /dev/null
    )"; then

      if [ -n "${branch_tag_match}" ]; then
        was_enabled=true
      fi
    fi
  fi

  if [ "${tag_setting}" = "true" ]; then
    if ! ${was_enabled}; then
      git tag -f "${tag_name}"
      git push -f "origin" "refs/tags/${tag_name}"
    fi
  elif [ "${tag_setting}" = "false" ]; then
    # Only need to delete branch tag if was_enabled, because
    # otherwise already doesn't exist.
    # - Always delete HEAD-only tag, in case stale one persists.
    if ${was_enabled} || [ "${tag_scope}" = "HEAD" ]; then
      git tag -d "${tag_name}" 2> /dev/null || true
      git push "origin" ":refs/tags/${tag_name}"
    fi
  fi

  trace_full "${output_name}: ${was_enabled}"

  trace_lite "├── $(printf '%-25s' "${tag_name}")" \
    "│ new val: $(printf '%-5s' "${tag_setting}")" \
    "│ $(printf '%-27s' "${output_name}:") ${was_enabled} │"

  if [ -n "${GITHUB_OUTPUT}" ]; then
    # Aka `if ${CI}; then`.
    echo "${output_name}=${was_enabled}" >> "${GITHUB_OUTPUT}"
  fi
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# (lb): These functions act in lieu of Bash (or shell) having any
# sort of object support, and are used to iterate over a list of
# object values, setting the same local variables with different
# values each time they're called.
# - This feels like an abuse of variable scoping (most languages
#   don't expose a called function's variables or values to the
#   caller, but the shell does), but I couldn't think of anything
#   DRYer, or simpler to implement. So like sorry not sorry?

set_tag_locals () {
  local which_tag="$1"

  # These fcns rely on `local` scoping to set these vars for the caller:
  #   tag_name, tag_setting, tag_scope, output_name, skip_if

  set_tag_locals_inhibit_cascade

  set_tag_locals_inhibit_cascade_always

  set_tag_locals_cascade_least

  set_tag_locals_cascade_alpha

  set_tag_locals_cascade_patch

  set_tag_locals_cascade_no_update_deps

  set_tag_locals_cascade_no_version_tag

  # ***

  tag_name="${which_tag}"
}

is_this_tag_object_specified () {
  local which_tag="$1"
  local tag_name="$2"
  # Caller local: tag_names

  trace_full "which_tag: ${which_tag}"
  trace_full "tag_name: ${tag_name}"

  # At first, caller leaves which_tag unset,
  # and we procure a list of all tag names.
  [ -n "${which_tag}" ] || tag_names+=("${tag_name}")

  # Then, caller iterates over the list of
  # tag names, and we set the `local` vars
  # for that tag.
  [ -n "${which_tag}" ] && [ "${which_tag}" = "${tag_name}" ]
}

# ***

set_tag_locals_inhibit_cascade () {
  # E.g., "ci-inhibit-cascade"
  tag_name="${EAPP_CI_TAG_INHIBIT_CASCADE}"
  if is_this_tag_object_specified "${which_tag}" "${tag_name}"; then
    tag_setting="${EAPP_INHIBIT_CASCADE}"
    tag_scope="HEAD"
    output_name="old_inhibit_cascade"
    skip_if=false
  fi
}

set_tag_locals_inhibit_cascade_always () {
  # E.g., "ci-inhibit-cascade-always"
  tag_name="${EAPP_CI_TAG_INHIBIT_CASCADE_ALWAYS}"
  if is_this_tag_object_specified "${which_tag}" "${tag_name}"; then
    tag_setting="${EAPP_INHIBIT_CASCADE_ALWAYS}"
    tag_scope="branch"
    output_name="old_inhibit_cascade_always"
    skip_if=false
  fi
}

set_tag_locals_cascade_least () {
  # E.g., "ci-cascade-least"
  tag_name="${EAPP_CI_TAG_CASCADE_LEAST}"
  if is_this_tag_object_specified "${which_tag}" "${tag_name}"; then
    tag_setting="${EAPP_CASCADE_LEAST}"
    tag_scope="HEAD"
    output_name="old_cascade_least"
    skip_if=false
  fi
}

set_tag_locals_cascade_alpha () {
  # E.g., "ci-cascade-alpha"
  tag_name="${EAPP_CI_TAG_CASCADE_ALPHA}"
  if is_this_tag_object_specified "${which_tag}" "${tag_name}"; then
    tag_setting="${EAPP_CASCADE_ALPHA}"
    tag_scope="HEAD"
    output_name="old_cascade_alpha"
    skip_if=false
  fi
}

set_tag_locals_cascade_patch () {
  # E.g., "ci-cascade-patch"
  tag_name="${EAPP_CI_TAG_CASCADE_PATCH}"
  if is_this_tag_object_specified "${which_tag}" "${tag_name}"; then
    tag_setting="${EAPP_CASCADE_PATCH}"
    tag_scope="HEAD"
    output_name="old_cascade_patch"
    skip_if=false
  fi
}

set_tag_locals_cascade_no_update_deps () {
  # E.g., "ci-cascade-no-update-deps"
  tag_name="${EAPP_CI_TAG_CASCADE_SKIP_DEPS}"
  if is_this_tag_object_specified "${which_tag}" "${tag_name}"; then
    tag_setting="${EAPP_CASCADE_SKIP_DEPS}"
    tag_scope="HEAD"
    output_name="old_cascade_skip_deps"
    skip_if=false
  fi
}

set_tag_locals_cascade_no_version_tag () {
  # E.g., "ci-cascade-no-version-tag"
  tag_name="${EAPP_CI_TAG_CASCADE_SKIP_VERS}"
  if is_this_tag_object_specified "${which_tag}" "${tag_name}"; then
    tag_setting="${EAPP_CASCADE_SKIP_VERS}"
    tag_scope="HEAD"
    output_name="old_cascade_skip_vers"
    skip_if=false
  fi
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

TRACE_LITE_ENABLE=${TRACE_LITE_ENABLE:-true}
TRACE_FULL_ENABLE=${TRACE_FULL_ENABLE:-false}

trace_lite () {
  ${TRACE_LITE_ENABLE} || return 0

  >&2 echo "$@"
}

trace_full () {
  ${TRACE_FULL_ENABLE} || return 0

  >&2 echo "$@"
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

main () {
  set -e

  wrangle_tags "$@"
}

if [ "$0" = "${BASH_SOURCE[0]}" ]; then
  # Being executed, so execute.
  main "$@"
fi

unset -f main

