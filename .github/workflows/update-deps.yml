# vim:tw=0:ts=2:sw=2:et:norl
# Author: Landon Bouma <https://tallybark.com/>
# Project: https://github.com/doblabs/easy-as-pypi#ðŸ¥§
# License: MIT

---

name: Release Cascade â€” Update

run-name: ðŸ‘£ â€” Cascade â€” 2.) Update deps ${{
  github.event_name == 'workflow_dispatch' && '(via User)' || '' }}

on:
  # Via spread-updates.yml from upstream project
  repository_dispatch:
    types: [update-deps]
    # Inputs are not defined, but are part of github.event.client_payload.
    # This workflow looks for the following inputs:
    #
    #   inputs:
    #     - cascade-updatedeps
    #     - cascade-versioning

  # Via sprout-updates.yml, via GitHub Actions button, via user
  workflow_call:
    inputs:
      cascade-updatedeps:
        description: 'Cascade poetry-update'
        type: string
        default: 'all'

      cascade-versioning:
        description: 'Cascade version bump'
        type: string
        default: 'alpha'

  # Via GitHub Actions website button, via user
  workflow_dispatch:
    inputs:
      bump-part:
        description: 'Increment version'
        type: choice
        options:
          - 'alpha'
          - 'patch'
          - 'least'
          - 'skip'
        default: 'alpha'

      cascade-dispatch:
        description: 'Start the cascade'
        type: boolean
        default: false

      cascade-updatedeps:
        description: 'Cascade poetry-update'
        type: choice
        options:
          - 'all'
          - 'ours'
          - 'skip'
        default: 'all'

      cascade-versioning:
        description: 'Cascade version bump'
        type: choice
        options:
          - 'alpha'
          - 'patch'
          - 'least'
          - 'skip'
        default: 'alpha'

# ***

env:
  # TRACK: https://github.com/actions/python-versions/releases
  # USYNC: workflows/ (PYTHON_VERSION), tox.ini (basepython), Makefile (VENV_PYVER).
  PYTHON_VERSION: 3.11

  # *** Munge possible input sources
  CASCADE_UPDATEDEPS: ${{
    github.event.client_payload.cascade-updatedeps
    || inputs.cascade-updatedeps
    || 'skip' }}
  CASCADE_VERSIONING: ${{
    github.event.client_payload.cascade-versioning
    || inputs.bump-part
    || inputs.cascade-versioning
    || 'skip' }}

jobs:
  # `env.` doesn't work from within `with:`, so kluge it.
  env-outputs:
    runs-on: ubuntu-latest
    steps:
      - run: |
          echo "CASCADE_UPDATEDEPS: ${CASCADE_UPDATEDEPS}"
          echo "CASCADE_VERSIONING: ${CASCADE_VERSIONING}"
    outputs:
      cascade-updatedeps: ${{ env.CASCADE_UPDATEDEPS }}
      cascade-versioning: ${{ env.CASCADE_VERSIONING }}

  # Here we check for branch tags (ci-inhibit-forever) and HEAD tags the
  # user might've set deliberately on this project. Because this is the
  # cascade entry point for a project (via repository_dispatch), HEAD
  # tags won't exist (CI didn't do it) unless user set them deliberately.
  wrangle-ci-tags:
    name: Wrangle (read) CI tags
    uses: ./.github/workflows/ci-tags-wrangle.yml

  poetry-update:
    name: Update lock deps

    needs: [env-outputs, wrangle-ci-tags]

    # Check for CI Git tags:
    # - Either ci-inhibit-cascade or ci-inhibit-forever will kill the
    #   cascade, and no further downstream repos will be dispatched.
    # - If ci-cascade-updatedeps is set and 'skip' â€” of course! â€” skip
    #   this poetry-update job, but keep the cascade going.
    # Also check the cascade-updatedeps input, either from upstream
    # repository_dispatch, or from user-initiated workflow_call (via
    # sprout-updates.yml, which exposes the workflow_dispatch inputs).
    if: true
      && needs.env-outputs.outputs.cascade-updatedeps != 'skip'
      && needs.wrangle-ci-tags.outputs.old-inhibit-cascade == 'false'
      && needs.wrangle-ci-tags.outputs.old-inhibit-forever == 'false'
      && needs.wrangle-ci-tags.outputs.old-cascade-updatedeps != 'skip'

    runs-on: ubuntu-latest

    steps:
      # SAVVY: How we'd access repository_dispatch args if we needed to add any:
      #  - run: |
      #      echo "event.client_payload.sha: ${{ github.event.client_payload.sha }}"
      #      echo "event.client_payload.ref: ${{ github.event.client_payload.ref }}"

      - name: Checkout this repo
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.repository.default_branch }}
          # Use the user token, not ${{ github.token }}, so that
          # git-push triggers workflow events. (Though TBH I don't
          # remember if it's the token setting here or the one on
          # bin/update-poetry, below that does this.)
          #  token: ${{ github.token }}
          token: ${{ secrets.USER_PAT }}

      - name: Install poetry
        run: pipx install poetry

      - name: Set up Python ${{ env.PYTHON_VERSION }}
        id: setup-python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'poetry'

      - name: Run bin/update-poetry
        id: run-update-poetry
        run: |
          env | grep -e "^UPDEPS_"

          new_pr_num="$(
            ./.github/bin/update-poetry
          )"

          echo "new_pr_num=${new_pr_num}" >> $GITHUB_OUTPUT
        env:
          # USER_TOKEN used with gh-label (manage 'poetry.lock' label),
          # and GBOT_TOKEN used to approve PR using different user:
          # - USER_TOKEN used on gh-pr-create and gh-pr-merge, and
          #   GBOT_TOKEN used on gh-pr-review.
          USER_TOKEN: ${{ secrets.USER_PAT }}
          GBOT_TOKEN: ${{ github.token }}
          # Organization variables (user email/name used on git-commit).
          UPDEPS_USER_EMAIL: ${{ vars.UPDEPS_USER_EMAIL }}
          UPDEPS_USER_NAME: ${{ vars.UPDEPS_USER_NAME }}
          UPDEPS_USER_NAME_UPDEPS: ${{ vars.UPDEPS_USER_NAME_UPDEPS }}
          # Project identifier (used to deduce remote name for git-push).
          UPDEPS_REPO_ORG_PROJ: ${{ github.repository }}
          # Inhibit cascade if "workflow_dispatch" and user didn't opt-in to
          # start the cascade (which happens after PR approved, after version
          # tag created, after checks pass, and after package is released and
          # smoke-tested).
          UPDEPS_CASCADE_INHIBIT: ${{
            github.event_name == 'workflow_dispatch'
            && ! inputs.cascade-dispatch }}
          # Whether to update all deps, or just "ours".
          # - This value is passed to the next project in the cascade, too.
          UPDEPS_CASCADE_UPDATEDEPS: ${{ env.CASCADE_UPDATEDEPS }}
          # Whether to version, and how, after PR is approved.
          # - Also passed along in the cascade.
          UPDEPS_CASCADE_VERSIONING: ${{ env.CASCADE_VERSIONING }}
          # Tweak the commit messages slightly to leave a source crumb.
          UPDEPS_COMMIT_MESSAGE_NORMAL: |
            'Build: Deps: Update poetry.lock [update-deps.yml]'
          # DEVXX: Use this to mock poetry-update, for faster dev/test.
          UPDEPS_FAKE_UPDATE: false

    outputs:
      new_pr_num: ${{ steps.run-update-poetry.outputs.new_pr_num }}

  # ***

  # If no PR, move on to versioning here. And if versioning being skipped,
  # versioning workflow will dispatch immediately to downstream repo(s).
  # Otherwise, if PR created, update-merged.yml workflow will continue
  # cascade after PR is merged, and new package version is released.
  update-merged:
    name: "Cascade maybe"

    uses: ./.github/workflows/update-merged.yml
    secrets: inherit

    needs: [env-outputs, wrangle-ci-tags, poetry-update]

    if: ${{ !cancelled()
        && needs.wrangle-ci-tags.outputs.old-inhibit-cascade == 'false'
        && needs.wrangle-ci-tags.outputs.old-inhibit-forever == 'false'
        && (needs.poetry-update.result == 'skipped'
            || (needs.poetry-update.result == 'success'
                && needs.poetry-update.outputs.new_pr_num == ''))
        && (github.event_name != 'workflow_dispatch'
            || inputs.cascade-dispatch)
      }}

    with:
      cascade-updatedeps: ${{ needs.env-outputs.outputs.cascade-updatedeps }}
      cascade-versioning: ${{ needs.env-outputs.outputs.cascade-versioning }}
