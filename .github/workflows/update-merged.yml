# vim:tw=0:ts=2:sw=2:et:norl
# Author: Landon Bouma <https://tallybark.com/>
# Project: https://github.com/doblabs/easy-as-pypi#🥧
# License: MIT

---

name: Release Cascade — Version

run-name: 👣 — Cascade — 3.) Version ${{
  github.event_name == 'workflow_dispatch' && '(via User)' || '' }}

on:
  # CXREF:
  # https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#
  #          running-your-pull_request-workflow-when-a-pull-request-merges
  # - Note pull_request, not pull_request_target, because (don't need/want) permissions.
  pull_request:
    types:
      - closed

  # Via .github/workflows/update-deps.yml.
  workflow_call:
    inputs:
      cascade-versioning:
        type: string
        # Use empty string to fallback Git tag value if input not set.
        default: ''

  # Via GitHub Actions website button
  workflow_dispatch:
    inputs:
      # If user wants to make a more "serious" release, they can bump major
      # or minor part from terminal, e.g., using `git-bump-version-tag`:
      #   https://github.com/thegittinsgood/git-bump-version-tag#🐫
      bump-part:
        description: 'Increment version'
        type: choice
        options:
          - 'alpha'
          - 'patch'
          - 'least'
          - 'skip'
        default: 'alpha'

      cascade-dispatch:
        description: 'Start the cascade'
        type: boolean
        default: false

      cascade-versioning:
        description: 'Cascade version bump'
        type: choice
        options:
          - 'alpha'
          - 'patch'
          - 'least'
          - 'skip'
        default: 'alpha'

# ***

# The workflow runs on *all* closed PRs, so we need to filter.
#
# - We'll skip the job itself if the PR is obviously inactionable:
#
#   - Check that the PR was merged. If not, there's nothing to do.
#
#   - Look for the 'poetry.lock' tag, added by .github/bin/update-poetry.
#
# - We'll run the job but fail if the tagged and merged PR looks fishy:
#
#   - Verify the tag name matches the .github/bin/update-poetry format.
#     E.g.,
#
#       $ jq .event.pull_request.head.ref pull_request.json
#       "update-deps/202311041112/9f9255a89e96"
#
#       $ jq .head_ref pull_request.json
#       "update-deps/202311041112/9f9255a89e96"
#
#     - Where pull_request.json is a local copy of a ${{ github }} dump:
#
#       - run: echo "${GITHUB_OBJ}"
#         env: GITHUB_OBJ: ${{ toJson(github) }}
#
# - There are a few more items we could verify, but currently don't:
#
#   - Verify it's the same user that update-poetry uses to make the PR.
#     E.g.,
#
#       $ jq .event.pull_request.user.login pull_request.json
#       "user"
#
#       # DUNNO: Are these the workflow actors? Do they always match
#       #   the PR user? Does the workflow runs as user who committed
#       #   HEAD? I should read up, and test with separate GH user.
#       $ jq .actor pull_request.json
#       "user"
#       $ jq .triggering_actor pull_request.json
#       "user"
#
#   - Verify the auto-merge properties:
#
#       $ jq .event.pull_request.auto_merge.enabled_by.login pull_request.json
#       "user"
#
#       $ jq .event.pull_request.auto_merge.merge_method pull_request.json
#       "rebase"
#
#   - Verify PR title and body
#
#       $ jq .event.pull_request.title pull_request.json
#       "Build: Bump poetry.lock (bump all)"
#
#       $ jq .event.pull_request.body pull_request.json
#       "Cascading release"

# ***

env:
  # USYNC: .github/bin/update-poetry defines these strings:
  #   UPDEPS_LABEL_NAME_VERSION_(ALPHA|PATCH|LEAST|SKIP)=\
  #     "ci-version-(alpha|patch|least|skip)"
  CASCADE_VERSIONING: ${{
    inputs.cascade-versioning
    || (contains(github.event.pull_request.labels.*.name, 'ci-version-alpha')
        && 'alpha')
    || (contains(github.event.pull_request.labels.*.name, 'ci-version-patch')
        && 'patch')
    || (contains(github.event.pull_request.labels.*.name, 'ci-version-least')
        && 'least')
    || (contains(github.event.pull_request.labels.*.name, 'ci-version-skip')
        && 'skip')
    || 'alpha' }}

# ***

jobs:

  verify-merged-pr:

    # USYNC: UPDEPS_LABEL_NAME_POETRY_LOCK="poetry.lock"
    if: github.event_name == 'pull_request'
      && github.event.pull_request.merged == true
      && contains(github.event.pull_request.labels.*.name, 'poetry.lock')

    runs-on: ubuntu-latest

    steps:
      - run: echo "The PR was merged, and it's labeled 'poetry.lock'"

      # Verify tag name looks like one of ours.
      - name: Verify tag name format — “${{ github.head_ref }}”
        run: |
          echo "${HEAD_REF}" | grep -E -e "^update-deps/[0-9]{12}/[0-9a-f]{12}$"
        env:
          HEAD_REF: ${{ github.head_ref }}

      # The verify-merged-pr steps are designed to exit nonzero to fail,
      # and then the next, bump job will check verify-merged-pr.result.

  # ***

  # Temporarily set HEAD tags pertinent to the current cascade. We
  # will clear these tags when we pass the cascade torch along later.
  wrangle-ci-tags:
    name: Wrangle (write) CI tag(s)

    needs: [verify-merged-pr]

    # USYNC: UPDEPS_LABEL_NAME_VERSION_SKIP="ci-version-skip"
    # SAVVY: When called via upstream repo-dispatch and update-deps.yml
    #        calls us via workflow_call, event is still repo-dispatch.
    if: ${{ ! cancelled()
      && inputs.cascade-versioning != 'skip'
      && ((github.event_name == 'repository_dispatch')
          || (github.event_name == 'workflow_dispatch'
              && inputs.cascade-dispatch
              && inputs.bump-part != 'skip')
          || (github.event_name == 'pull_request'
              && needs.verify-merged-pr.result == 'success'
              && ! contains(github.event.pull_request.labels.*.name, 'ci-version-skip'))
         ) }}

    uses: ./.github/workflows/ci-tags-wrangle.yml

    # Note we only set CI tags here, and we don't reference the outputs later.
    with:
      # Manage "ci-inhibit-cascade"
      inhibit-cascade: github.event_name == 'workflow_dispatch'
        && ! inputs.cascade-dispatch
        || contains(github.event.pull_request.labels.*.name, 'ci-inhibit-cascade')

  # ***

  bump-version-maybe:

    runs-on: ubuntu-latest

    needs: wrangle-ci-tags

    if: ${{ ! cancelled() && needs.wrangle-ci-tags.result == 'success' }}

    steps:
      - name: Checkout this repo
        uses: actions/checkout@v4
        with:
          # Fetch all history, so rev-parse HEAD is real HEAD,
          # and we get tag history, so git-bump can read version.
          fetch-depth: 0
          # Use user token, not default github.token, so git-push tag
          # triggers release workflow.
          token: ${{ secrets.USER_PAT }}
          # By default, checkout installs within ${{ github.workspace }},
          # i.e., it won't checkout to a new directory, it'll just occupy
          # the workspace, e.g., '/home/runner/work/easy-as-pypi/easy-as-pypi'.
          # - And then if you run checkout again without a 'path', it clobbers
          #   the same location. So we need to use 'path' to use checkout twice.
          # - Here we install project repo to "${{ github.workspace }}/versionee",
          #   e.g., '/home/runner/work/easy-as-pypi/easy-as-pypi/versionee'.
          # - Not that you need to know all that, just that the repo will be in the
          #   root workspace dir at versionee/ and git-bump will be at versioner/.
          path: 'versionee'

      # ***

      - name: Checkout git-bump
        uses: actions/checkout@v4
        with:
          repository: 'landonb/git-bump-version-tag'
          # INERT: Pin the version. But we own the tool, so trust in HEAD.
          #  ref: ''
          # Relative path under $GITHUB_WORKSPACE to place the repository.
          path: 'versioner'

      - name: Install Dunamai
        run: pipx install dunamai

      - name: Prepare committer
        run: |
          assert_git_email_known_ci () {
            test -n "${UPDEPS_USER_EMAIL}" \
              && return 0 || true

            >&2 echo "ERROR: Please set UPDEPS_USER_EMAIL " \
              "organization or project variable"

            exit 1
          }
          assert_git_email_known_ci

          cd ./versionee/
          git config user.email "${UPDEPS_USER_EMAIL}"
          git config user.name \
            "${UPDEPS_USER_NAME_VERSION:-${UPDEPS_USER_NAME:-release-bot}}"
        env:
          UPDEPS_USER_EMAIL: ${{ vars.UPDEPS_USER_EMAIL }}
          UPDEPS_USER_NAME: ${{ vars.UPDEPS_USER_NAME }}
          UPDEPS_USER_NAME_VERSION: ${{ vars.UPDEPS_USER_NAME_VERSION }}

      - name: Bump it...
        run: |
          export PATH="$(pwd)/versioner/bin:${PATH}"
          cd ./versionee/
          # By default, runs:
          #  git bump-version-tag least
          echo "git bump-version-tag \"${BUMP_PART}\""
          git bump-version-tag "${BUMP_PART}"

    env:
      # Uses bump-part input if workflow_dispatch;
      # or looks for special CI label if pull_request;
      # finally falls-back 'alpha' (which is bump's default).
      BUMP_PART: ${{ inputs.bump-part || env.CASCADE_VERSIONG }}

  # ***

  # `envs.` doesn't work from `with:`, so kluge it.
  env-outputs:
    runs-on: ubuntu-latest
    steps:
      - run: |
          echo "CASCADE_VERSIONING: ${CASCADE_VERSIONING}"
    outputs:
      cascade-versioning: ${{ env.CASCADE_VERSIONING }}

  # ***

  # If no new version/release, continue cascade; otherwise checks-versioned.yml
  # et al run, and cascade eventually continues from release-smoke-test.yml.
  update-cascade:
    name: "Cascade maybe"

    uses: ./.github/workflows/update-cascade.yml
    secrets: inherit

    needs: [verify-merged-pr, env-outputs]

    # Sorta the opposite of wrangle-ci-tags's 'if' condition.
    # SAVVY: Note this won't casade if git-bump ran but didn't change the version.
    if: ${{ ! cancelled()
      && ((github.event_name == 'repository_dispatch')
          || (github.event_name == 'workflow_dispatch'
              && inputs.cascade-dispatch
              && inputs.bump-part == 'skip')
          || (github.event_name == 'pull_request'
              && needs.verify-merged-pr.result == 'success'
              && contains(github.event.pull_request.labels.*.name, 'ci-version-skip'))
         ) }}

    with:
      cascade-versioning: ${{ needs.env-outputs.outputs.cascade-versioning }}
